from typing import List


class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        pass

"""
这道题是一道典型的应用DP来解的题，
如果我们看到这种求总数，而不是列出所有情况的题，十有八九都是用DP来解，重中之重就是在于找出递推式。
如果你第一反应没有想到用DP来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到0或者1就将对应的m和n的值减小，
这种方法在有的时候是不对的，
比如对于{“11”, “01”, “10”}，m=2，n=2这个例子，
我们将遍历完“11”的时候，把1用完了，那么对于后面两个字符串就没法处理了，
而其实正确的答案是应该组成后面两个字符串才对。
所以我们需要建立一个二维的DP数组，
其中dp[i][j]表示有i个0和j个1时能组成的最多字符串的个数，
而对于当前遍历到的字符串，我们统计出其中0和1的个数为zeros和ones，
然后dp[i - zeros][j - ones]表示当前的i和j减去zeros和ones之前能拼成字符串的个数，
那么加上当前的zeros和ones就是当前dp[i][j]可以达到的个数，
我们跟其原有数值对比取较大值即可，所以递推式如下：
"""
if __name__ == '__main__':
    Solution().findMaxForm()